#include "graph_io.hpp"
#include <algorithm>
#include <execution>
#include <format>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <sstream>
#include <mpi.h>

namespace skg {

namespace {

void EnsureDirectoryExists(const std::filesystem::path& path) {
    if (!path.parent_path().empty() && !std::filesystem::exists(path.parent_path())) {
        std::filesystem::create_directories(path.parent_path());
    }
}

[[nodiscard]] std::string FormatNumber(std::int64_t number) {
    std::stringstream ss;
    ss.imbue(std::locale(""));
    ss << std::fixed << number;
    return ss.str();
}

struct GraphStatistics {
    std::int64_t total_nodes{0};
    std::int64_t total_edges{0};
    std::int64_t min_degree{std::numeric_limits<std::int64_t>::max()};
    std::int64_t max_degree{0};
    double average_degree{0.0};
    double degree_variance{0.0};
    std::int64_t isolated_nodes{0};
    
    void CalculateLocal(const CSRMatrix<>& matrix) {
        const auto row_ptrs = matrix.RowPointers();
        total_nodes = matrix.NumNodes();
        total_edges = matrix.NumEdges();
        
        std::vector<std::int64_t> degrees(total_nodes);
        
        std::transform(std::execution::par_unseq,
                      std::views::iota(std::int64_t{0}, total_nodes).begin(),
                      std::views::iota(std::int64_t{0}, total_nodes).end(),
                      degrees.begin(),
                      [&row_ptrs](std::int64_t i) {
            return row_ptrs[i + 1] - row_ptrs[i];
        });
        
        auto [min_it, max_it] = std::minmax_element(
            std::execution::par_unseq, degrees.begin(), degrees.end()
        );
        min_degree = *min_it;
        max_degree = *max_it;
        
        average_degree = std::reduce(std::execution::par_unseq,
                                    degrees.begin(), degrees.end(), 0.0) / total_nodes;
        
        degree_variance = std::transform_reduce(
            std::execution::par_unseq,
            degrees.begin(), degrees.end(),
            0.0,
            std::plus<>(),
            [this](std::int64_t degree) {
                double diff = degree - average_degree;
                return diff * diff;
            }
        ) / total_nodes;
        
        isolated_nodes = std::count(std::execution::par_unseq,
                                   degrees.begin(), degrees.end(), 0);
    }
    
    void ReduceGlobal(int mpi_rank, int mpi_size) {
        MPI_Allreduce(MPI_IN_PLACE, &total_edges, 1, MPI_LONG_LONG, MPI_SUM, MPI_COMM_WORLD);
        MPI_Allreduce(MPI_IN_PLACE, &min_degree, 1, MPI_LONG_LONG, MPI_MIN, MPI_COMM_WORLD);
        MPI_Allreduce(MPI_IN_PLACE, &max_degree, 1, MPI_LONG_LONG, MPI_MAX, MPI_COMM_WORLD);
        MPI_Allreduce(MPI_IN_PLACE, &isolated_nodes, 1, MPI_LONG_LONG, MPI_SUM, MPI_COMM_WORLD);
        
        total_nodes *= mpi_size;
        
        double sum_degrees = average_degree * (total_nodes / mpi_size);
        MPI_Allreduce(MPI_IN_PLACE, &sum_degrees, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
        average_degree = sum_degrees / total_nodes;
        
        MPI_Allreduce(MPI_IN_PLACE, &degree_variance, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
        degree_variance /= mpi_size;
    }
};

}  

void GraphIO::WriteTextFormat(std::filesystem::path filepath,
                              const CSRMatrix<>& matrix) const {
    EnsureDirectoryExists(filepath);
    
    auto temp_filepath = filepath;
    temp_filepath.replace_filename(
        std::format("{}_{}.tmp", filepath.stem().string(), mpi_rank_)
    );
    
    std::ofstream file(temp_filepath);
    if (!file) {
        throw std::runtime_error(std::format("Failed to open file: {}", 
                                            temp_filepath.string()));
    }
    
    if (mpi_rank_ == 0) {
        file << "# Stochastic Kronecker Graph\n";
        file << "# Format: source_node target_node weight\n";
        file << "# Generated by SKG C++20 Implementation\n";
        
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        file << "# Timestamp: " << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S") << "\n";
        file << "#\n";
    }
    
    const auto row_ptrs = matrix.RowPointers();
    const auto col_indices = matrix.ColumnIndices();
    const auto values = matrix.Values();
    const std::int64_t base_node = mpi_rank_ * matrix.NumNodes();
    
    for (std::int64_t i = 0; i < matrix.NumNodes(); ++i) {
        const std::int64_t global_node = base_node + i;
        
        for (auto j = row_ptrs[i]; j < row_ptrs[i + 1]; ++j) {
            file << global_node << " " << col_indices[j] << " " 
                 << std::fixed << std::setprecision(6) << values[j] << "\n";
        }
    }
    
    file.close();
    
    MPI_Barrier(MPI_COMM_WORLD);
    
    if (mpi_rank_ == 0) {
        std::ofstream final_file(filepath);
        if (!final_file) {
            throw std::runtime_error(std::format("Failed to create final file: {}",
                                                filepath.string()));
        }
        
        for (int rank = 0; rank < mpi_size_; ++rank) {
            auto rank_file = filepath;
            rank_file.replace_filename(
                std::format("{}_{}.tmp", filepath.stem().string(), rank)
            );
            
            std::ifstream input(rank_file);
            if (input) {
                final_file << input.rdbuf();
                input.close();
                std::filesystem::remove(rank_file);
            }
        }
        
        final_file.close();
        
        std::cout << "✓ Graph saved to " << filepath << " (text format)\n";
    }
    
    MPI_Barrier(MPI_COMM_WORLD);
}

void GraphIO::WriteBinaryFormat(std::filesystem::path filepath,
                               const CSRMatrix<>& matrix) const {
    EnsureDirectoryExists(filepath);
    
    ParallelFileWriter writer(filepath);
    writer.Open();
    if (mpi_rank_ == 0) {
        BinaryHeader header;
        header.total_nodes = matrix.NumNodes() * mpi_size_;
        header.num_processes = mpi_size_;
        
        std::int64_t total_edges = matrix.NumEdges();
        MPI_Reduce(MPI_IN_PLACE, &total_edges, 1, MPI_LONG_LONG, 
                  MPI_SUM, 0, MPI_COMM_WORLD);
        header.total_edges = total_edges;
        
        writer.Write(std::span{&header, 1}, 0);
    } else {
        std::int64_t edges = matrix.NumEdges();
        MPI_Reduce(&edges, nullptr, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);
    }
    
    std::int64_t edges_before = 0;
    std::int64_t my_edges = matrix.NumEdges();
    MPI_Exscan(&my_edges, &edges_before, 1, MPI_LONG_LONG, MPI_SUM, MPI_COMM_WORLD);
    
    MPI_Offset offset = sizeof(BinaryHeader) + 
                       edges_before * (2 * sizeof(std::int64_t) + sizeof(float));
    
    const auto row_ptrs = matrix.RowPointers();
    const auto col_indices = matrix.ColumnIndices();
    const auto values = matrix.Values();
    const std::int64_t base_node = mpi_rank_ * matrix.NumNodes();
    
    struct BinaryEdge {
        std::int64_t source;
        std::int64_t target;
        float weight;
    };
    
    std::vector<BinaryEdge> edges;
    edges.reserve(matrix.NumEdges());
    
    for (std::int64_t i = 0; i < matrix.NumNodes(); ++i) {
        const std::int64_t global_node = base_node + i;
        
        for (auto j = row_ptrs[i]; j < row_ptrs[i + 1]; ++j) {
            edges.push_back({global_node, col_indices[j], values[j]});
        }
    }
    
    writer.WriteCollective(std::span{edges}, offset);
    writer.Close();
    
    if (mpi_rank_ == 0) {
        auto file_size = std::filesystem::file_size(filepath);
        std::cout << std::format("✓ Graph saved to {} (binary format, {} bytes)\n",
                               filepath.string(), FormatNumber(file_size));
    }
}

void GraphIO::WriteStatistics(std::filesystem::path filepath,
                             const CSRMatrix<>& matrix) const {
    EnsureDirectoryExists(filepath);
    
    GraphStatistics stats;
    stats.CalculateLocal(matrix);
    stats.ReduceGlobal(mpi_rank_, mpi_size_);
    
    if (mpi_rank_ == 0) {
        std::ofstream file(filepath);
        if (!file) {
            throw std::runtime_error(std::format("Failed to open statistics file: {}",
                                                filepath.string()));
        }
        
        file << "╔══════════════════════════════════════════════╗\n";
        file << "║        Graph Statistics Summary              ║\n";
        file << "╚══════════════════════════════════════════════╝\n\n";
        
        file << "Graph Properties:\n";
        file << "├─ Total Nodes: " << FormatNumber(stats.total_nodes) << "\n";
        file << "├─ Total Edges: " << FormatNumber(stats.total_edges) << "\n";
        file << "├─ Average Degree: " << std::fixed << std::setprecision(2) 
             << stats.average_degree << "\n";
        file << "├─ Degree Variance: " << std::fixed << std::setprecision(2)
             << stats.degree_variance << "\n";
        file << "├─ Min Degree: " << stats.min_degree << "\n";
        file << "├─ Max Degree: " << stats.max_degree << "\n";
        file << "├─ Isolated Nodes: " << stats.isolated_nodes << "\n";
        file << "└─ Graph Density: " << std::scientific << std::setprecision(4)
             << (2.0 * stats.total_edges) / (stats.total_nodes * (stats.total_nodes - 1))
             << "\n\n";
        
        file << "Distribution Information:\n";
        file << "├─ MPI Processes: " << mpi_size_ << "\n";
        file << "├─ Nodes per Process: " << stats.total_nodes / mpi_size_ << "\n";
        file << "├─ Avg Edges per Process: " 
             << std::fixed << std::setprecision(2) 
             << static_cast<double>(stats.total_edges) / mpi_size_ << "\n";
        
        if (stats.max_degree > 0 && stats.min_degree > 0) {
            double gamma_estimate = 1.0 + stats.total_nodes / 
                                   (stats.total_nodes * std::log(stats.max_degree / stats.min_degree));
            file << "└─ Estimated γ (power-law): " 
                 << std::fixed << std::setprecision(2) << gamma_estimate << "\n\n";
        }
        
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        file << "Generated: " << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S") << "\n";
        
        file.close();
        
        std::cout << "✓ Statistics saved to " << filepath << "\n";
    }
}

std::unique_ptr<CSRMatrix<>> GraphIO::ReadBinaryFormat(
    std::filesystem::path filepath) const {
    
    if (!std::filesystem::exists(filepath)) {
        throw std::runtime_error(std::format("File not found: {}", filepath.string()));
    }
    
    ParallelFileWriter reader(filepath);
    reader.Open();
    
    BinaryHeader header;
    MPI_File file_handle;
    MPI_File_open(MPI_COMM_WORLD, filepath.string().c_str(),
                 MPI_MODE_RDONLY, MPI_INFO_NULL, &file_handle);
    
    if (mpi_rank_ == 0) {
        MPI_Status status;
        MPI_File_read(file_handle, &header, sizeof(BinaryHeader), 
                     MPI_BYTE, &status);
    }
    
    MPI_Bcast(&header, sizeof(BinaryHeader), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    if (!header.IsValid()) {
        MPI_File_close(&file_handle);
        throw std::runtime_error("Invalid binary file format");
    }
    
    const std::int64_t edges_per_process = header.total_edges / mpi_size_;
    const std::int64_t extra_edges = header.total_edges % mpi_size_;
    const std::int64_t my_edges = edges_per_process + (mpi_rank_ < extra_edges ? 1 : 0);
    
    std::int64_t edges_before = edges_per_process * mpi_rank_ + 
                                std::min(static_cast<std::int64_t>(mpi_rank_), extra_edges);
    
    MPI_Offset offset = sizeof(BinaryHeader) + 
                       edges_before * (2 * sizeof(std::int64_t) + sizeof(float));
    
    struct BinaryEdge {
        std::int64_t source;
        std::int64_t target;
        float weight;
    };
    
    std::vector<BinaryEdge> edges(my_edges);
    MPI_Status status;
    MPI_File_read_at(file_handle, offset, edges.data(),
                     my_edges * sizeof(BinaryEdge), MPI_BYTE, &status);
    
    MPI_File_close(&file_handle);
    
    std::vector<DefaultEdge> edge_list;
    edge_list.reserve(my_edges);
    
    for (const auto& e : edges) {
        edge_list.emplace_back(e.source, e.target, e.weight);
    }
    
    const std::int64_t nodes_per_process = header.total_nodes / mpi_size_;
    return std::make_unique<CSRMatrix<>>(
        CSRMatrix<>::CreateFromEdgeList(edge_list, nodes_per_process)
    );
}

ParallelFileWriter::ParallelFileWriter(ParallelFileWriter&& other) noexcept
    : filepath_(std::move(other.filepath_)),
      file_handle_(other.file_handle_),
      is_open_(other.is_open_) {
    other.file_handle_ = MPI_FILE_NULL;
    other.is_open_ = false;
}

ParallelFileWriter& ParallelFileWriter::operator=(ParallelFileWriter&& other) noexcept {
    if (this != &other) {
        if (is_open_) {
            Close();
        }
        filepath_ = std::move(other.filepath_);
        file_handle_ = other.file_handle_;
        is_open_ = other.is_open_;
        other.file_handle_ = MPI_FILE_NULL;
        other.is_open_ = false;
    }
    return *this;
}

void ParallelFileWriter::Open() {
    if (is_open_) {
        return;
    }
    
    int access_mode = MPI_MODE_CREATE | MPI_MODE_WRONLY;
    
    if (MPI_File_open(MPI_COMM_WORLD, filepath_.string().c_str(),
                     access_mode, MPI_INFO_NULL, &file_handle_) != MPI_SUCCESS) {
        throw std::runtime_error(std::format("Failed to open file: {}", 
                                            filepath_.string()));
    }
    
    is_open_ = true;
}

void ParallelFileWriter::Close() {
    if (!is_open_) {
        return;
    }
    
    MPI_File_close(&file_handle_);
    is_open_ = false;
}

}  